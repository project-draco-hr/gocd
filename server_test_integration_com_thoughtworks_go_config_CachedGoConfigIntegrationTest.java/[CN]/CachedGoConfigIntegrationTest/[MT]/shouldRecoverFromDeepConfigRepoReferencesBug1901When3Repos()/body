{
  File secondDownstreamExternalConfigRepo=temporaryFolder.newFolder();
  String secondDownstreamLatestCommit=setupExternalConfigRepo(secondDownstreamExternalConfigRepo,"external_git_config_repo_referencing_second");
  configHelper.addConfigRepo(new ConfigRepoConfig(new GitMaterialConfig(secondDownstreamExternalConfigRepo.getAbsolutePath()),"gocd-xml"));
  File firstDownstreamExternalConfigRepo=temporaryFolder.newFolder();
  String firstDownstreamLatestCommit=setupExternalConfigRepo(firstDownstreamExternalConfigRepo,"external_git_config_repo_referencing_first");
  configHelper.addConfigRepo(new ConfigRepoConfig(new GitMaterialConfig(firstDownstreamExternalConfigRepo.getAbsolutePath()),"gocd-xml"));
  goConfigService.forceNotifyListeners();
  ConfigRepoConfig firstDownstreamConfigRepo=configWatchList.getCurrentConfigRepos().get(1);
  ConfigRepoConfig secondDownstreamConfigRepo=configWatchList.getCurrentConfigRepos().get(2);
  assertThat(configWatchList.getCurrentConfigRepos().size(),is(3));
  repoConfigDataSource.onCheckoutComplete(secondDownstreamConfigRepo.getMaterialConfig(),secondDownstreamExternalConfigRepo,secondDownstreamLatestCommit);
  List<ServerHealthState> messageForInvalidMerge=serverHealthService.filterByScope(HealthStateScope.forPartialConfigRepo(secondDownstreamConfigRepo));
  assertThat(messageForInvalidMerge.isEmpty(),is(false));
  assertThat(messageForInvalidMerge.get(0).getDescription(),containsString("tries to fetch artifact from pipeline &quot;downstream&quot;"));
  assertThat(goConfigService.hasPipelineNamed(new CaseInsensitiveString("downstream2")),is(false));
  assertThat(cachedGoPartials.lastKnownPartials().size(),is(1));
  assertThat(cachedGoPartials.lastValidPartials().size(),is(0));
  assertThat(cachedGoPartials.lastKnownPartials().get(0).getGroups().get(0).hasPipeline(new CaseInsensitiveString("downstream2")),is(true));
  repoConfigDataSource.onCheckoutComplete(firstDownstreamConfigRepo.getMaterialConfig(),firstDownstreamExternalConfigRepo,firstDownstreamLatestCommit);
  messageForInvalidMerge=serverHealthService.filterByScope(HealthStateScope.forPartialConfigRepo(firstDownstreamConfigRepo));
  assertThat(messageForInvalidMerge.isEmpty(),is(false));
  assertThat(messageForInvalidMerge.get(0).getDescription(),containsString("Pipeline &quot;pipe1&quot; does not exist. It is used from pipeline &quot;downstream&quot"));
  assertThat(goConfigService.hasPipelineNamed(new CaseInsensitiveString("downstream")),is(false));
  assertThat(goConfigService.hasPipelineNamed(new CaseInsensitiveString("downstream2")),is(false));
  assertThat(cachedGoPartials.lastKnownPartials().size(),is(2));
  assertThat(cachedGoPartials.lastValidPartials().size(),is(0));
  repoConfigDataSource.onCheckoutComplete(configRepo.getMaterialConfig(),externalConfigRepo,latestCommit);
  assertThat(serverHealthService.filterByScope(HealthStateScope.forPartialConfigRepo(firstDownstreamConfigRepo)).isEmpty(),is(true));
  assertThat(serverHealthService.filterByScope(HealthStateScope.forPartialConfigRepo(secondDownstreamConfigRepo)).isEmpty(),is(true));
  assertThat(cachedGoConfig.currentConfig().hasPipelineNamed(new CaseInsensitiveString("pipe1")),is(true));
  assertThat(cachedGoConfig.currentConfig().hasPipelineNamed(new CaseInsensitiveString("downstream")),is(true));
  assertThat(cachedGoConfig.currentConfig().hasPipelineNamed(new CaseInsensitiveString("downstream2")),is(true));
}
