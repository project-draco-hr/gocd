{
  int cs=EVIL;
  IRubyObject result=null;
{
    cs=JSON_value_start;
  }
{
    int _klen;
    int _trans=0;
    int _acts;
    int _nacts;
    int _keys;
    int _goto_targ=0;
    _goto:     while (true) {
switch (_goto_targ) {
case 0:
        if (p == pe) {
          _goto_targ=4;
          continue _goto;
        }
      if (cs == 0) {
        _goto_targ=5;
        continue _goto;
      }
case 1:
    _acts=_JSON_value_from_state_actions[cs];
  _nacts=(int)_JSON_value_actions[_acts++];
while (_nacts-- > 0) {
switch (_JSON_value_actions[_acts++]) {
case 9:
{
      p--;
{
        p+=1;
        _goto_targ=5;
        if (true)         continue _goto;
      }
    }
  break;
}
}
_match: do {
_keys=_JSON_value_key_offsets[cs];
_trans=_JSON_value_index_offsets[cs];
_klen=_JSON_value_single_lengths[cs];
if (_klen > 0) {
int _lower=_keys;
int _mid;
int _upper=_keys + _klen - 1;
while (true) {
if (_upper < _lower) break;
_mid=_lower + ((_upper - _lower) >> 1);
if (data[p] < _JSON_value_trans_keys[_mid]) _upper=_mid - 1;
 else if (data[p] > _JSON_value_trans_keys[_mid]) _lower=_mid + 1;
 else {
  _trans+=(_mid - _keys);
  break _match;
}
}
_keys+=_klen;
_trans+=_klen;
}
_klen=_JSON_value_range_lengths[cs];
if (_klen > 0) {
int _lower=_keys;
int _mid;
int _upper=_keys + (_klen << 1) - 2;
while (true) {
if (_upper < _lower) break;
_mid=_lower + (((_upper - _lower) >> 1) & ~1);
if (data[p] < _JSON_value_trans_keys[_mid]) _upper=_mid - 2;
 else if (data[p] > _JSON_value_trans_keys[_mid + 1]) _lower=_mid + 2;
 else {
  _trans+=((_mid - _keys) >> 1);
  break _match;
}
}
_trans+=_klen;
}
}
 while (false);
cs=_JSON_value_trans_targs[_trans];
if (_JSON_value_trans_actions[_trans] != 0) {
_acts=_JSON_value_trans_actions[_trans];
_nacts=(int)_JSON_value_actions[_acts++];
while (_nacts-- > 0) {
switch (_JSON_value_actions[_acts++]) {
case 0:
{
result=getRuntime().getNil();
}
break;
case 1:
{
result=getRuntime().getFalse();
}
break;
case 2:
{
result=getRuntime().getTrue();
}
break;
case 3:
{
if (parser.allowNaN) {
result=getConstant(CONST_NAN);
}
 else {
throw unexpectedToken(p - 2,pe);
}
}
break;
case 4:
{
if (parser.allowNaN) {
result=getConstant(CONST_INFINITY);
}
 else {
throw unexpectedToken(p - 7,pe);
}
}
break;
case 5:
{
if (pe > p + 9 - (parser.quirksMode ? 1 : 0) && absSubSequence(p,p + 9).equals(JSON_MINUS_INFINITY)) {
if (parser.allowNaN) {
result=getConstant(CONST_MINUS_INFINITY);
{
p=((p + 10)) - 1;
}
p--;
{
p+=1;
_goto_targ=5;
if (true) continue _goto;
}
}
 else {
throw unexpectedToken(p,pe);
}
}
parseFloat(res,p,pe);
if (res.result != null) {
result=res.result;
{
p=((res.p)) - 1;
}
}
parseInteger(res,p,pe);
if (res.result != null) {
result=res.result;
{
p=((res.p)) - 1;
}
}
p--;
{
p+=1;
_goto_targ=5;
if (true) continue _goto;
}
}
break;
case 6:
{
parseString(res,p,pe);
if (res.result == null) {
p--;
{
p+=1;
_goto_targ=5;
if (true) continue _goto;
}
}
 else {
result=res.result;
{
p=((res.p)) - 1;
}
}
}
break;
case 7:
{
currentNesting++;
parseArray(res,p,pe);
currentNesting--;
if (res.result == null) {
p--;
{
p+=1;
_goto_targ=5;
if (true) continue _goto;
}
}
 else {
result=res.result;
{
p=((res.p)) - 1;
}
}
}
break;
case 8:
{
currentNesting++;
parseObject(res,p,pe);
currentNesting--;
if (res.result == null) {
p--;
{
p+=1;
_goto_targ=5;
if (true) continue _goto;
}
}
 else {
result=res.result;
{
p=((res.p)) - 1;
}
}
}
break;
}
}
}
case 2:
if (cs == 0) {
_goto_targ=5;
continue _goto;
}
if (++p != pe) {
_goto_targ=1;
continue _goto;
}
case 4:
case 5:
}
break;
}
}
if (cs >= JSON_value_first_final && result != null) {
res.update(result,p);
}
 else {
res.update(null,p);
}
}
