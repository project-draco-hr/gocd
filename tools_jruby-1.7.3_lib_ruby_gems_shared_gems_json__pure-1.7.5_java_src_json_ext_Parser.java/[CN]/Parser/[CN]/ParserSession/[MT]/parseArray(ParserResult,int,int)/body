{
  int cs=EVIL;
  if (parser.maxNesting > 0 && currentNesting > parser.maxNesting) {
    throw newException(Utils.M_NESTING_ERROR,"nesting of " + currentNesting + " is too deep");
  }
  IRubyObject result;
  if (parser.arrayClass == getRuntime().getArray()) {
    result=RubyArray.newArray(getRuntime());
  }
 else {
    result=parser.arrayClass.newInstance(context,IRubyObject.NULL_ARRAY,Block.NULL_BLOCK);
  }
{
    cs=JSON_array_start;
  }
{
    int _klen;
    int _trans=0;
    int _acts;
    int _nacts;
    int _keys;
    int _goto_targ=0;
    _goto:     while (true) {
switch (_goto_targ) {
case 0:
        if (p == pe) {
          _goto_targ=4;
          continue _goto;
        }
      if (cs == 0) {
        _goto_targ=5;
        continue _goto;
      }
case 1:
    _match:     do {
      _keys=_JSON_array_key_offsets[cs];
      _trans=_JSON_array_index_offsets[cs];
      _klen=_JSON_array_single_lengths[cs];
      if (_klen > 0) {
        int _lower=_keys;
        int _mid;
        int _upper=_keys + _klen - 1;
        while (true) {
          if (_upper < _lower)           break;
          _mid=_lower + ((_upper - _lower) >> 1);
          if (data[p] < _JSON_array_trans_keys[_mid])           _upper=_mid - 1;
 else           if (data[p] > _JSON_array_trans_keys[_mid])           _lower=_mid + 1;
 else {
            _trans+=(_mid - _keys);
            break _match;
          }
        }
        _keys+=_klen;
        _trans+=_klen;
      }
      _klen=_JSON_array_range_lengths[cs];
      if (_klen > 0) {
        int _lower=_keys;
        int _mid;
        int _upper=_keys + (_klen << 1) - 2;
        while (true) {
          if (_upper < _lower)           break;
          _mid=_lower + (((_upper - _lower) >> 1) & ~1);
          if (data[p] < _JSON_array_trans_keys[_mid])           _upper=_mid - 2;
 else           if (data[p] > _JSON_array_trans_keys[_mid + 1])           _lower=_mid + 2;
 else {
            _trans+=((_mid - _keys) >> 1);
            break _match;
          }
        }
        _trans+=_klen;
      }
    }
 while (false);
  _trans=_JSON_array_indicies[_trans];
cs=_JSON_array_trans_targs[_trans];
if (_JSON_array_trans_actions[_trans] != 0) {
_acts=_JSON_array_trans_actions[_trans];
_nacts=(int)_JSON_array_actions[_acts++];
while (_nacts-- > 0) {
switch (_JSON_array_actions[_acts++]) {
case 0:
{
      parseValue(res,p,pe);
      if (res.result == null) {
        p--;
{
          p+=1;
          _goto_targ=5;
          if (true)           continue _goto;
        }
      }
 else {
        if (parser.arrayClass == getRuntime().getArray()) {
          ((RubyArray)result).append(res.result);
        }
 else {
          result.callMethod(context,"<<",res.result);
        }
{
          p=((res.p)) - 1;
        }
      }
    }
  break;
case 1:
{
  p--;
{
    p+=1;
    _goto_targ=5;
    if (true)     continue _goto;
  }
}
break;
}
}
}
case 2:
if (cs == 0) {
_goto_targ=5;
continue _goto;
}
if (++p != pe) {
_goto_targ=1;
continue _goto;
}
case 4:
case 5:
}
break;
}
}
if (cs >= JSON_array_first_final) {
res.update(result,p + 1);
}
 else {
throw unexpectedToken(p,pe);
}
}
