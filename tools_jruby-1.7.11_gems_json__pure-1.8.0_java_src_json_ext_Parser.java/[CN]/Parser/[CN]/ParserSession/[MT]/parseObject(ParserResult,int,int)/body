{
  int cs=EVIL;
  IRubyObject lastName=null;
  boolean objectDefault=true;
  if (parser.maxNesting > 0 && currentNesting > parser.maxNesting) {
    throw newException(Utils.M_NESTING_ERROR,"nesting of " + currentNesting + " is too deep");
  }
  IRubyObject result;
  if (parser.objectClass == getRuntime().getHash()) {
    result=RubyHash.newHash(getRuntime());
  }
 else {
    objectDefault=false;
    result=parser.objectClass.newInstance(context,IRubyObject.NULL_ARRAY,Block.NULL_BLOCK);
  }
{
    cs=JSON_object_start;
  }
{
    int _klen;
    int _trans=0;
    int _acts;
    int _nacts;
    int _keys;
    int _goto_targ=0;
    _goto:     while (true) {
switch (_goto_targ) {
case 0:
        if (p == pe) {
          _goto_targ=4;
          continue _goto;
        }
      if (cs == 0) {
        _goto_targ=5;
        continue _goto;
      }
case 1:
    _match:     do {
      _keys=_JSON_object_key_offsets[cs];
      _trans=_JSON_object_index_offsets[cs];
      _klen=_JSON_object_single_lengths[cs];
      if (_klen > 0) {
        int _lower=_keys;
        int _mid;
        int _upper=_keys + _klen - 1;
        while (true) {
          if (_upper < _lower)           break;
          _mid=_lower + ((_upper - _lower) >> 1);
          if (data[p] < _JSON_object_trans_keys[_mid])           _upper=_mid - 1;
 else           if (data[p] > _JSON_object_trans_keys[_mid])           _lower=_mid + 1;
 else {
            _trans+=(_mid - _keys);
            break _match;
          }
        }
        _keys+=_klen;
        _trans+=_klen;
      }
      _klen=_JSON_object_range_lengths[cs];
      if (_klen > 0) {
        int _lower=_keys;
        int _mid;
        int _upper=_keys + (_klen << 1) - 2;
        while (true) {
          if (_upper < _lower)           break;
          _mid=_lower + (((_upper - _lower) >> 1) & ~1);
          if (data[p] < _JSON_object_trans_keys[_mid])           _upper=_mid - 2;
 else           if (data[p] > _JSON_object_trans_keys[_mid + 1])           _lower=_mid + 2;
 else {
            _trans+=((_mid - _keys) >> 1);
            break _match;
          }
        }
        _trans+=_klen;
      }
    }
 while (false);
  _trans=_JSON_object_indicies[_trans];
cs=_JSON_object_trans_targs[_trans];
if (_JSON_object_trans_actions[_trans] != 0) {
_acts=_JSON_object_trans_actions[_trans];
_nacts=(int)_JSON_object_actions[_acts++];
while (_nacts-- > 0) {
switch (_JSON_object_actions[_acts++]) {
case 0:
{
      parseValue(res,p,pe);
      if (res.result == null) {
        p--;
{
          p+=1;
          _goto_targ=5;
          if (true)           continue _goto;
        }
      }
 else {
        if (parser.objectClass == getRuntime().getHash()) {
          ((RubyHash)result).op_aset(context,lastName,res.result);
        }
 else {
          result.callMethod(context,"[]=",new IRubyObject[]{lastName,res.result});
        }
{
          p=((res.p)) - 1;
        }
      }
    }
  break;
case 1:
{
  parseString(res,p,pe);
  if (res.result == null) {
    p--;
{
      p+=1;
      _goto_targ=5;
      if (true)       continue _goto;
    }
  }
 else {
    RubyString name=(RubyString)res.result;
    if (parser.symbolizeNames) {
      lastName=context.getRuntime().is1_9() ? name.intern19() : name.intern();
    }
 else {
      lastName=name;
    }
{
      p=((res.p)) - 1;
    }
  }
}
break;
case 2:
{
p--;
{
p+=1;
_goto_targ=5;
if (true) continue _goto;
}
}
break;
}
}
}
case 2:
if (cs == 0) {
_goto_targ=5;
continue _goto;
}
if (++p != pe) {
_goto_targ=1;
continue _goto;
}
case 4:
case 5:
}
break;
}
}
if (cs < JSON_object_first_final) {
res.update(null,p + 1);
return;
}
IRubyObject returnedResult=result;
if (parser.createAdditions) {
IRubyObject vKlassName;
if (objectDefault) {
vKlassName=((RubyHash)result).op_aref(context,parser.createId);
}
 else {
vKlassName=result.callMethod(context,"[]",parser.createId);
}
if (!vKlassName.isNil()) {
IRubyObject klass=parser.info.jsonModule.get().callMethod(context,"deep_const_get",vKlassName);
if (klass.respondsTo("json_creatable?") && klass.callMethod(context,"json_creatable?").isTrue()) {
returnedResult=klass.callMethod(context,"json_create",result);
}
}
}
res.update(returnedResult,p + 1);
}
