{
  int cs=EVIL;
  IRubyObject result=null;
{
    cs=JSON_string_start;
  }
  int memo=p;
{
    int _klen;
    int _trans=0;
    int _acts;
    int _nacts;
    int _keys;
    int _goto_targ=0;
    _goto:     while (true) {
switch (_goto_targ) {
case 0:
        if (p == pe) {
          _goto_targ=4;
          continue _goto;
        }
      if (cs == 0) {
        _goto_targ=5;
        continue _goto;
      }
case 1:
    _match:     do {
      _keys=_JSON_string_key_offsets[cs];
      _trans=_JSON_string_index_offsets[cs];
      _klen=_JSON_string_single_lengths[cs];
      if (_klen > 0) {
        int _lower=_keys;
        int _mid;
        int _upper=_keys + _klen - 1;
        while (true) {
          if (_upper < _lower)           break;
          _mid=_lower + ((_upper - _lower) >> 1);
          if (data[p] < _JSON_string_trans_keys[_mid])           _upper=_mid - 1;
 else           if (data[p] > _JSON_string_trans_keys[_mid])           _lower=_mid + 1;
 else {
            _trans+=(_mid - _keys);
            break _match;
          }
        }
        _keys+=_klen;
        _trans+=_klen;
      }
      _klen=_JSON_string_range_lengths[cs];
      if (_klen > 0) {
        int _lower=_keys;
        int _mid;
        int _upper=_keys + (_klen << 1) - 2;
        while (true) {
          if (_upper < _lower)           break;
          _mid=_lower + (((_upper - _lower) >> 1) & ~1);
          if (data[p] < _JSON_string_trans_keys[_mid])           _upper=_mid - 2;
 else           if (data[p] > _JSON_string_trans_keys[_mid + 1])           _lower=_mid + 2;
 else {
            _trans+=((_mid - _keys) >> 1);
            break _match;
          }
        }
        _trans+=_klen;
      }
    }
 while (false);
  _trans=_JSON_string_indicies[_trans];
cs=_JSON_string_trans_targs[_trans];
if (_JSON_string_trans_actions[_trans] != 0) {
_acts=_JSON_string_trans_actions[_trans];
_nacts=(int)_JSON_string_actions[_acts++];
while (_nacts-- > 0) {
switch (_JSON_string_actions[_acts++]) {
case 0:
{
      int offset=byteList.begin();
      ByteList decoded=decoder.decode(byteList,memo + 1 - offset,p - offset);
      result=getRuntime().newString(decoded);
      if (result == null) {
        p--;
{
          p+=1;
          _goto_targ=5;
          if (true)           continue _goto;
        }
      }
 else {
{
          p=((p + 1)) - 1;
        }
      }
    }
  break;
case 1:
{
  p--;
{
    p+=1;
    _goto_targ=5;
    if (true)     continue _goto;
  }
}
break;
}
}
}
case 2:
if (cs == 0) {
_goto_targ=5;
continue _goto;
}
if (++p != pe) {
_goto_targ=1;
continue _goto;
}
case 4:
case 5:
}
break;
}
}
if (parser.createAdditions) {
RubyHash match_string=parser.match_string;
if (match_string != null) {
final IRubyObject[] memoArray={result,null};
try {
match_string.visitAll(new RubyHash.Visitor(){
@Override public void visit(IRubyObject pattern,IRubyObject klass){
if (pattern.callMethod(context,"===",memoArray[0]).isTrue()) {
memoArray[1]=klass;
throw JumpException.SPECIAL_JUMP;
}
}
}
);
}
 catch (JumpException e) {
}
if (memoArray[1] != null) {
RubyClass klass=(RubyClass)memoArray[1];
if (klass.respondsTo("json_creatable?") && klass.callMethod(context,"json_creatable?").isTrue()) {
result=klass.callMethod(context,"json_create",result);
}
}
}
}
if (cs >= JSON_string_first_final && result != null) {
RuntimeInfo info=RuntimeInfo.forRuntime(context.getRuntime());
if (info.encodingsSupported() && result instanceof RubyString) {
((RubyString)result).force_encoding(context,info.utf8.get());
}
res.update(result,p + 1);
}
 else {
res.update(null,p + 1);
}
}
